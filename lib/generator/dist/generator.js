// Generated by CoffeeScript 1.9.3
var RESTClient, init, jsx, path;

jsx = jsx || {};

init = function() {
  var INDENT_STR, RE_ASSET_FILE, _cheerio, _moduleDir, beautify, exec, fs, html2jade, htmlTemplate, nib, path, stylus, stylusTemplate;
  RE_ASSET_FILE = /"[^"]+\.(png|jpg|gif|json|svg|swf|mp3|mp4|mov|wav|ogg|webm)"/gm;
  INDENT_STR = '  ';
  exec = require('exec');
  beautify = require('js-beautify');
  path = require('path');
  fs = require('fs');
  _cheerio = require('cheerio');
  html2jade = require('html2jade');
  stylus = require('stylus');
  nib = require('nib');
  htmlTemplate = new jsx.HtmlTemplate();
  stylusTemplate = new jsx.StylusTemplate();
  _moduleDir = module.filename.replace(/\/[^\/]+$/, '/');
  return jsx.LayoutPreviewGenerator = (function() {
    var $, _assets, _compareNodeHeight, _componentExportable, _components, _copyComponentAssets, _copyHTMLAssets, _createComponentCSS, _createComponentFiles, _createComponents, _createDestDir, _createElementCSS, _createElementTag, _createHTML, _createPackageJson, _createTextElementCSS, _data, _deleteQuartFromURLText, _generateCSS, _generateNode, _generateNodeList, _generateRelativeLayout, _getAssetFilePathList, _getBasicStyle, _getIndent, _getMetaData, _getStylePSE, _getText, _isComponent, _isComponentDebugJS, _isFullURL, _isIgnoreAssetFilePath, _isPositionRelative, _makeAssetPathList, _packageJsonTemplate, _params, _ref_elements, _replaceAssetPath, _replaceJadeFormat, _setAssetPathList, _setClassPath, _setComponentFiles, _writePackageJsonTemplate;

    _data = null;

    _params = null;

    _components = null;

    _assets = 'test_layout-assets/';

    _componentExportable = true;

    _ref_elements = {};

    _packageJsonTemplate = '';

    $ = null;

    function LayoutPreviewGenerator() {}

    LayoutPreviewGenerator.prototype.load = function(data) {
      _data = data;
    };

    LayoutPreviewGenerator.prototype.generate = function(params) {
      var $body, $main, body, cssFile, cssPath, dest, doc, html, htmlFile, jadeFile, jsPath, style, stylusFile;
      _params = params;
      doc = _data.document;
      $ = _cheerio.load('<div><div id="main" class="_' + doc.filename + '"></div></div>', {
        decodeEntities: false
      });
      $body = $('div');
      $main = $('div#main');
      if (!dest) {
        dest = '../app/build';
      }
      _components = [];
      _ref_elements = {};
      htmlFile = path.join(_params.dest_dir, _params.filename);
      jadeFile = './src/pages/' + _params.filename.replace('.html', '.jade');
      cssFile = path.join(_params.dest_dir, 'css');
      cssFile = path.join(cssFile, path.basename(htmlFile).replace('.html', '.css'));
      stylusFile = './src/pages/css/' + _params.filename.replace('.html', '.styl');
      cssPath = path.relative(path.dirname(htmlFile), cssFile);
      jsPath = cssPath.replace(/[^\/]+\/([^.]+)\.css/, 'js/$1.js');
      params = {};
      style = _getBasicStyle(_data.document);
      _generateRelativeLayout(_data, $main, params);
      style += params.css;
      body = $body.html();
      body = '<div id="container">' + body + '</div>';
      if (_componentExportable) {
        body += htmlTemplate.scriptTags(jsPath);
      }
      html = _createHTML(doc.title, cssPath, body);
      html = beautify.html(html);
      return _createDestDir(dest, function() {
        fs.writeFile(htmlFile, html, {
          encoding: 'utf8'
        }, null);
        return _copyHTMLAssets(html, function() {
          if (_params.export_jade) {
            return exec('mkdir -p ' + './src/pages', function() {
              return html2jade.convertHtml(html, {
                donotencode: true
              }, function(err, jade) {
                jade = _replaceJadeFormat(jade);
                fs.writeFile(jadeFile, jade, {
                  encoding: 'utf8'
                }, null);
                exec('mkdir -p ' + './src/pages/css', function() {
                  fs.writeFile(stylusFile, style, {
                    encoding: 'utf8'
                  }, null);
                  return _generateCSS(cssFile, style);
                });
                if (_componentExportable) {
                  return _createComponents();
                }
              });
            });
          } else {
            if (_componentExportable) {
              return _createComponents();
            }
          }
        });
      });
    };

    _createDestDir = function(dest, callback) {
      var dir;
      dir = [path.join(dest, 'js'), path.join(dest, 'css'), 'src/pages/js', 'src/pages/css', 'src/assets', 'src/libs'].join(' ');
      return exec('mkdir -p ' + dir, function() {
        if (callback) {
          return callback();
        }
      });
    };

    _replaceJadeFormat = function(jade) {
      jade = jade.replace(/([\r\n]+)\s+\|\s*[\r\n]+/g, '$1');
      jade = jade.replace(/\/\/\s/g, '//');
      jade = jade.split('//- if (debug) {').join('- if (debug) {');
      jade = jade.split('//- }').join('- }');
      return jade;
    };

    _generateCSS = function(cssFile, style) {
      return stylus(style).set('compress', false).use(nib()).render(function(err, css) {
        if (err) {
          return console.log('stylus #render() >>', err);
        } else {
          return fs.writeFile(cssFile, css, {
            encoding: 'utf8'
          }, null);
        }
      });
    };

    _getAssetFilePathList = function(dest, filePathList) {
      return filePathList.forEach(function(filePath) {
        var src;
        filePath = _deleteQuartFromURLText(filePath);
        src = path.dirname(filePath);
        if (_isIgnoreAssetFilePath(filePath)) {

        } else if (dest.indexOf(src) < 0) {
          return dest.push(src);
        }
      });
    };

    _isIgnoreAssetFilePath = function(path) {
      if (_isFullURL(path)) {
        return true;
      }
      if (_isComponentDebugJS(path)) {
        return true;
      }
      return false;
    };

    _isFullURL = function(url) {
      return url.match(/^https?:\/\//) !== null;
    };

    _isComponentDebugJS = function(path) {
      return path.indexOf('html-component-debug.js') >= 0;
    };

    _deleteQuartFromURLText = function(text) {
      return text.replace(/"/g, '');
    };

    _copyHTMLAssets = function(html, callback) {
      var copyList, dstDir, j, len1, matches, pathes, src, srcDir, src_diff_1, src_diff_2;
      pathes = [];
      matches = html.match(RE_ASSET_FILE);
      if (matches) {
        _getAssetFilePathList(pathes, matches);
      }
      copyList = [];
      for (j = 0, len1 = pathes.length; j < len1; j++) {
        src = pathes[j];
        src_diff_1 = path.join(_params.cwd, src.replace(_params.assets_src_path, _params.assets_dest));
        src_diff_2 = path.join(_params.cwd, _params.assets_dest);
        srcDir = path.join(_params.assets_src, src_diff_1.replace(src_diff_2, ''));
        dstDir = path.dirname(src_diff_1);
        copyList.push({
          mkdir: dstDir,
          cpSrc: srcDir,
          cpDst: dstDir
        });
      }
      return _copyComponentAssets(null, {
        assets: copyList
      }, callback);
    };

    _createComponents = function() {
      var data, isWritable, packageJson, packageJsonPath;
      if (!_packageJsonTemplate) {
        _writePackageJsonTemplate(_packageJsonTemplate);
      }
      data = _components.shift();
      if (data) {
        packageJsonPath = 'components/' + data.name + '/package.json';
        isWritable = true;
        if (_isComponent(packageJsonPath)) {
          packageJson = fs.readFileSync(packageJsonPath, {
            encoding: 'utf8'
          });
          packageJson = JSON.parse(packageJson);
          if (packageJson.version !== '0.0.0') {
            _createComponents();
            return;
          }
        }
        console.log('create component #' + data.name);
        return _setComponentFiles(data);
      }
    };

    _writePackageJsonTemplate = function(_packageJsonTemplate) {
      var tmplPath;
      tmplPath = path.join(_moduleDir, '../../../template/package.json');
      return _packageJsonTemplate = fs.readFileSync(tmplPath, {
        encoding: 'utf8'
      });
    };

    _isComponent = function(packageJsonPath) {
      return fs.existsSync(packageJsonPath);
    };

    _setComponentFiles = function(data) {
      var cssFile, html;
      html = data.node.html();
      html = '<div class="pse ' + data.name + '">' + html + '</div>';
      cssFile = data.name + '.css';
      return stylusTemplate.componentBaseCSS(function(baseCSS) {
        var params;
        html = _createHTML(data.name, cssFile, html, true, baseCSS);
        html = beautify.html(html);
        params = _replaceAssetPath(data, html);
        return _copyComponentAssets(data, params, function() {
          return _createComponentFiles(data, params, function() {
            _createPackageJson(data);
            return _createComponents();
          });
        });
      });
    };

    _createPackageJson = function(data) {
      var filePath, json;
      filePath = 'components/' + data.name + '/package.json';
      filePath = path.join(_params.cwd, filePath);
      json = _packageJsonTemplate.split('${name}').join(data.name);
      return fs.writeFileSync(filePath, json, {
        encoding: 'utf8'
      });
    };

    _replaceAssetPath = function(data, html) {
      var dstBase, j, len1, matches, pathes, result, src;
      pathes = [];
      result = {
        html: html,
        base: 'components/' + data.name + '/dist/',
        assets: []
      };
      dstBase = result.base;
      matches = html.match(RE_ASSET_FILE);
      if (matches != null) {
        matches.forEach(function(code) {
          return _makeAssetPathList(code, pathes);
        });
      }
      for (j = 0, len1 = pathes.length; j < len1; j++) {
        src = pathes[j];
        _setAssetPathList(src, result);
      }
      return result;
    };

    _setAssetPathList = function(src, result) {
      var asset, dst, dstDir, srcDir;
      asset = path.join('component-assets', src.replace(_params.assets_src_path, ''));
      srcDir = path.join(_params.assets_src, src.replace(_params.assets_src_path, ''));
      dst = path.join(dstBase, asset);
      dstDir = path.join(_params.cwd, path.dirname(dst));
      result.html = result.html.split(src).join(asset);
      return result.assets.push({
        mkdir: dst,
        cpSrc: srcDir,
        cpDst: dstDir
      });
    };

    _makeAssetPathList = function(code, pathes) {
      var src;
      code = code.replace(/"/g, '');
      src = path.dirname(code);
      if (code.match(/^https?:\/\//) || code.indexOf('html-component-debug.js') >= 0) {

      } else if (pathes.indexOf(src) < 0) {
        return pathes.push(src);
      }
    };

    _createComponentFiles = function(data, params, callback) {
      var cssFile, dstDir, htmlFile, jadeFile, srcDir, stylFile, style;
      dstDir = 'components/' + data.name + '/dist/';
      srcDir = 'components/' + data.name + '/src/';
      style = data.data.css;
      htmlFile = './' + dstDir + data.name + '.html';
      cssFile = './' + dstDir + data.name + '.css';
      jadeFile = './' + srcDir + data.name + '.jade';
      stylFile = './' + srcDir + data.name + '.styl';
      return exec('mkdir -p ' + dstDir, function() {
        fs.writeFileSync(htmlFile, params.html, {
          encoding: 'utf8'
        });
        _generateCSS(cssFile, style);
        if (_params.export_jade) {
          return exec('mkdir -p ' + srcDir, function() {
            return html2jade.convertHtml(params.html, {
              donotencode: true
            }, function(err, jade) {
              jade = _replaceJadeFormat(jade);
              fs.writeFileSync(jadeFile, jade, {
                encoding: 'utf8'
              });
              fs.writeFileSync(stylFile, style, {
                encoding: 'utf8'
              });
              return callback();
            });
          });
        } else {
          return callback();
        }
      });
    };

    _copyComponentAssets = function(data, params, callback) {
      var copyProc, item, j, len1, nextProc, procList, ref;
      procList = [];
      copyProc = function(asset) {
        return function() {
          return exec('mkdir -p ' + asset.mkdir, function() {
            var cmd;
            cmd = ['cp -fr', asset.cpSrc, asset.cpDst].join(' ');
            return exec(cmd, function() {
              return nextProc();
            });
          });
        };
      };
      nextProc = function() {
        var proc;
        proc = procList.shift();
        if (proc) {
          return proc();
        } else {
          return callback();
        }
      };
      ref = params.assets;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        item = ref[j];
        procList.push(copyProc(item));
      }
      return nextProc();
    };

    _createHTML = function(title, cssPath, body, exportComment, baseCSS) {
      var code, jsPath;
      code = htmlTemplate.head(title);
      if (exportComment) {
        jsPath = cssPath.replace('.css', '.js');
        code += htmlTemplate.componentCssCode(cssPath, baseCSS);
        code += htmlTemplate.componentBodyCode(body, htmlTemplate.componentScriptTags(jsPath));
      } else {
        code += _getMetaData();
        code += htmlTemplate.cssCode(cssPath);
        code += htmlTemplate.bodyCode(body);
      }
      return code;
    };

    _getMetaData = function() {
      return htmlTemplate.metaData(_data.meta);
    };

    _generateRelativeLayout = function(params, $main, result) {
      var className, doc, indentLevel, indexes, layers, offsetX, offsetY;
      doc = params.document;
      layers = params.layers;
      indexes = params.index;
      offsetX = doc.offsetX;
      offsetY = doc.offsetY;
      className = '_' + doc.filename;
      result.css = '.' + className + '\n';
      indentLevel = 1;
      return _generateNodeList(indexes.children, className, indentLevel, doc, layers, $main, $main, result, doc.offsetX, doc.offsetY, className, false);
    };

    _generateNodeList = function(list, parentName, indentLevel, doc, layers, $root, $element, result, offsetX, offsetY, component, isRoot) {
      var child, j, len1, results;
      results = [];
      for (j = 0, len1 = list.length; j < len1; j++) {
        child = list[j];
        if (child.enabled) {
          results.push(_generateNode(child, parentName, indentLevel, doc, layers, $root, $element, result, offsetX, offsetY, component, isRoot));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    _createElementTag = function(id, layers) {
      var data, meta, option, tag;
      data = layers[id];
      option = data.option;
      meta = data.meta;
      tag = '';
      if (meta.type === 'text') {
        tag = _getText(meta.text.text);
      } else if (meta.type === 'image') {
        tag = htmlTemplate.imageBlock(meta, _params.assets_src_path);
      }
      if (option != null ? option.link_url : void 0) {
        tag = '<a href="' + option.link_url + '" target="' + option.link_target + '">' + tag + '</a>';
      }
      tag = '<div class="pse ' + option.name + '">' + tag + '</div>';
      return tag;
    };

    _generateNode = function(node, parentName, indentLevel, doc, layers, $root, $element, result, offsetX, offsetY, component, isRoot) {
      var $$, $copm, $div, childContainer, className, classPath, cname, css, data, id, isComponentRoot, meta, option, ref_id, ref_node, tag;
      id = node.id;
      data = layers[id];
      option = data.option;
      meta = data.meta;
      tag = _createElementTag(id, layers);
      className = option.name;
      classPath = _setClassPath(parentName, className);
      $$ = _cheerio.load(tag, {
        decodeEntities: false
      });
      $div = $$('div');
      childContainer = $div;
      if (option != null ? option.link_url : void 0) {
        childContainer = $$('a');
      }
      isComponentRoot = isRoot;
      if (_componentExportable && data.option.component) {
        isComponentRoot = true;
        component = data.option.component;
        className = component;
        result.css += _createComponentCSS(id, className, indentLevel, node, layers, offsetX, offsetY);
        result = {
          css: ''
        };
        indentLevel = 0;
      }
      css = _createElementCSS(id, className, indentLevel, node, layers, offsetX, offsetY, component, isComponentRoot);
      result.css += css + '\n';
      if (doc.referers.indexOf(id) >= 0) {
        _ref_elements[id] = childContainer;
      }
      if (option.embed) {
        childContainer.append(unescape(option.embed));
      } else if (option.layer_name.match(/^@\d+/)) {
        ref_id = option.layer_name.match(/^@(\d+)/)[1];
        ref_node = _ref_elements[ref_id];
        if (ref_node) {
          childContainer.append(ref_node.html());
        }
      } else {
        _generateNodeList(node.children, classPath, indentLevel + 1, doc, layers, $root, childContainer, result, 0, 0, component, false);
      }
      if (_componentExportable && data.option.component) {
        cname = data.option.component;
        _components.push({
          id: id,
          name: cname,
          node: $div,
          data: result
        });
        $copm = _cheerio.load('<' + cname + '></' + cname + '>', {
          decodeEntities: false
        })(cname);
        return $element.append($copm);
      } else {
        return $element.append($div);
      }
    };

    _setClassPath = function(parentName, className) {
      var classPath;
      if (parentName) {
        classPath = parentName + ' ' + className;
        return classPath;
      } else {
        classPath = className;
        return classPath;
      }
    };

    _createComponentCSS = function(id, classPath, indentLevel, node, layers, offsetX, offsetY) {
      var _indent, css, data, isRelative, meta, parent;
      data = layers[id];
      meta = data.meta;
      _indent = _getIndent(indentLevel, INDENT_STR);
      css = '';
      if (_indent) {
        css += _indent + '& > .' + classPath + '\n';
      } else {
        css += _indent + '.' + classPath + '\n';
      }
      _indent += INDENT_STR;
      data.top = meta.position.relative.y + offsetY;
      data.left = meta.position.relative.x + offsetX;
      isRelative = _isPositionRelative(data, meta, node, layers);
      parent = layers[data.parent_id];
      css += stylusTemplate.position(data, _indent, parent, isRelative, false);
      return css;
    };

    _createElementCSS = function(id, classPath, indentLevel, node, layers, offsetX, offsetY, component, isComponentRoot) {
      var _indent, css, data, isRelative, meta, parent;
      data = layers[id];
      meta = data.meta;
      _indent = _getIndent(indentLevel, INDENT_STR);
      css = '';
      if (_indent) {
        css += _indent + '& > .' + classPath + '\n';
      } else {
        css += _indent + '.' + classPath + '\n';
      }
      _indent += INDENT_STR;
      if (meta.text) {
        css += _createTextElementCSS(meta, _indent);
      }
      data.top = meta.position.relative.y + offsetY;
      data.left = meta.position.relative.x + offsetX;
      if (data.background && data.background.image) {
        css += stylusTemplate.background(data, _indent, _params.assets_src_path);
      }
      isRelative = _isPositionRelative(data, meta, node, layers);
      parent = layers[data.parent_id];
      css += stylusTemplate.position(data, _indent, parent, isRelative, isComponentRoot);
      css += stylusTemplate.size(data, _indent);
      css += '';
      css += '';
      return css;
    };

    _getIndent = function(level, str) {
      var code, i, j, ref;
      if (!str) {
        str = '\t';
      }
      code = '';
      for (i = j = 0, ref = level; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        code += str;
      }
      return code;
    };

    _createTextElementCSS = function(meta, indent) {
      return stylusTemplate.textElement(meta, indent);
    };

    _isPositionRelative = function(data, meta, node, layers) {
      var prev;
      if (node.prev_id) {
        prev = layers[node.prev_id];
        if (prev) {
          return _compareNodeHeight(prev, data, node, meta);
        }
      }
      if (!node.prev_id) {
        return true;
      }
      return false;
    };

    _compareNodeHeight = function(prev, data, node, meta) {
      if (prev.bounds.bottom <= data.bounds.top) {
        data.top = data.bounds.top - prev.bounds.bottom;
        return true;
      }
      if (node.positionRelative) {
        data.top = meta.position.absolute.y - prev.bounds.bottom;
        return true;
      }
    };

    _getBasicStyle = function(params) {
      return stylusTemplate.basicStyle(params);
    };

    _getStylePSE = function() {
      return stylusTemplate.pse();
    };

    _getText = function(text) {
      return htmlTemplate.textBlock(text);
    };

    return LayoutPreviewGenerator;

  })();
};

jsx.init = init;

module.exports = jsx;

jsx = jsx || {};

jsx.HtmlTemplate = (function() {
  function HtmlTemplate() {}

  HtmlTemplate.prototype.head = function(title) {
    var code;
    code = '<!DOCTYPE html><html><head>';
    code += '<meta charset="utf-8">';
    code += '<title>' + title + '</title>';
    code += '<meta name="viewport" content="width=device-width, initial-scale=1">';
    return code;
  };

  HtmlTemplate.prototype.scriptTags = function(jsPath) {
    var code;
    code = '';
    code += '<script src="../components/libs/bundle.js"></script>';
    code += '<!--- if (debug) {-->';
    code += '<script src="../components/html-component/dist/env.js"></script>';
    code += '<script src="../components/html-component/dist/html-component.js"></script>';
    code += '<script src="../components/html-component/dist/html-component-debug.js"></script>';
    code += '<!--- }-->';
    code += '<!--include components-js-->';
    code += '<!--script(src="' + jsPath + '")-->';
    return code;
  };

  HtmlTemplate.prototype.componentScriptTags = function(jsPath) {
    var code;
    code = '';
    code += '<script src="../../libs/bundle.js" exclude></script>';
    code += '<script src="../../html-component/dist/env.js" exclude></script>';
    code += '<script src="../../html-component/dist/html-component.js" exclude></script>';
    code += '<script src="../../html-component/dist/html-component-debug.js" exclude></script>';
    code += '<!--script(src="' + jsPath + '")-->';
    return code;
  };

  HtmlTemplate.prototype.bodyCode = function(body) {
    var code;
    code = '';
    code += '<body>' + body;
    code += '</body></html>';
    return code;
  };

  HtmlTemplate.prototype.componentBodyCode = function(body, script) {
    var code;
    code = '';
    code += '<body><!--export-->' + body;
    code += script;
    code += '<!--/export-->';
    code += '</body></html>';
    return code;
  };

  HtmlTemplate.prototype.cssCode = function(cssPath) {
    var code;
    code = '';
    code += '<!--- if (debug) {-->';
    code += '<link rel="stylesheet" href="../components/html-component/dist/html-component.css">';
    code += '<!--- }-->';
    code += '<!--include components-css-->';
    code += '<link rel="stylesheet" href="' + cssPath + '">';
    code += '</head>';
    return code;
  };

  HtmlTemplate.prototype.componentCssCode = function(cssPath, excludeCSS) {
    var code;
    code = '';
    code += '<link rel="stylesheet" href="../../html-component/dist/html-component.css" exclude>';
    code += '<style exclude>';
    code += excludeCSS || '';
    code += '</style>';
    code += '<!--export-->';
    code += '<link rel="stylesheet" href="' + cssPath + '">';
    code += '<!--/export-->';
    code += '</head>';
    return code;
  };

  HtmlTemplate.prototype.imageBlock = function(meta, assetsPath) {
    var alt, tag;
    alt = meta.image.text.join('');
    tag = '<img';
    tag += ' src="' + path.join(assetsPath, meta.image.url) + '"';
    if (alt) {
      alt = alt.replace(/[\r\n]/gm, '');
      tag += ' alt="' + alt + '"';
    }
    tag += '>';
    return tag;
  };

  HtmlTemplate.prototype.textBlock = function(text) {
    var texts;
    texts = text.split('\n\n');
    text = '<p>' + texts.join('</p><p>') + '</p>';
    text = text.replace(/\n/g, '<br>');
    return text;
  };

  HtmlTemplate.prototype.metaData = function(meta) {
    var code;
    code = '';
    if (meta) {
      code += '<meta name="description" content="' + meta.meta_description + '">';
      code += '<meta name="keywords" content="' + meta.meta_keywords + '">';
      code += '<meta name="viewport" content="width=device-width,initial-scale=1">';
      code += '<meta property="og:title" content="' + meta.meta_name + '">';
      code += '<meta property="og:site_name" content="' + meta.meta_name + '">';
      code += '<meta property="og:type" content="website">';
      code += '<meta property="og:url" content="' + meta.meta_url + '">';
      code += '<meta property="og:description" content="' + meta.meta_description + '">';
      code += '<meta property="og:image" content="' + meta.meta_image + '">';
      code += '<meta property="og:locale" content="' + meta.meta_locale + '">';
      code += '<meta http-equiv="X-UA-Compatible" content="IE=edge">';
      code += '<meta http-equiv="Content-Style-Type" content="text/css">';
      code += '<meta http-equiv="Content-Script-Type" content="text/javascript">';
      code += '<!--link rel="apple-touch-icon" href="images/touch-icon-iphone.png"-->';
      code += '<!--link rel="shortcut icon" href="images/favicon.ico"-->';
    }
    return code;
  };

  return HtmlTemplate;

})();

module.exports = jsx;

jsx = jsx || {};

RESTClient = require('node-rest-client').Client;

jsx.LayoutJSONParser = (function() {
  var _data, _indexPositionSort, _layouts, _meta, _options, _setupDocumentData, _setupIndexData, _setupLayoutNodesData;

  _layouts = null;

  _options = null;

  _meta = null;

  _data = null;

  function LayoutJSONParser() {}

  LayoutJSONParser.prototype.load = function(layoutJson, callback) {
    var client, e;
    _layouts = require(layoutJson);
    _options = _layouts.options;
    if (_options.root.docs_url) {
      try {
        client = new RESTClient();
        client.get(_options.root.docs_url, function(data, response) {
          var cols, e, i, j, key, len, ref, tsv, value;
          try {
            if (data) {
              _meta = {};
              tsv = String(data).split('\r\n');
              len = tsv.length;
              for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                cols = tsv[i].split('\t');
                key = cols[1];
                value = cols[2];
                _meta[key] = value;
              }
            }
          } catch (_error) {
            e = _error;
            console.log('Parse Error : Google Spreadsheets');
          }
          if (callback) {
            return callback();
          }
        });
      } catch (_error) {
        e = _error;
        console.log('Load Error : Google Spreadsheets');
      }
      if (callback) {
        return callback();
      }
    } else {
      if (callback) {
        return callback();
      }
    }
  };

  LayoutJSONParser.prototype.parse = function() {
    _data = {
      meta: _meta
    };
    _setupDocumentData(_data, _layouts, _options);
    _setupIndexData(_layouts.index, _layouts.layers);
    _setupLayoutNodesData(_data, _layouts, _options);
    return _data;
  };

  _setupIndexData = function(index, layers) {
    var bottomBorder, i, isPositionRelative, item, j, k, l, layer, len, list, maxY, minY, next, next_id, option, parent, parent_id, prev_id, ref, ref1, ref2, results;
    list = index.children;
    len = list.length;
    prev_id = null;
    next_id = null;
    parent_id = index.id;
    minY = 9999999999;
    maxY = 0;
    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      item = list[i];
      layer = layers[item.id];
      if (layer) {
        layer.parent_id = parent_id;
        layer.childIndex = i;
      }
      option = _options[item.id];
      if (option.use_background) {
        parent = layers[parent_id];
        parent.background = {
          image: option.layer_name,
          pos_x: option.horizontal,
          pos_y: option.vertical
        };
        item.enabled = false;
        option.enabled = false;
        item.top = 0;
        item.left = 0;
        item.bottom = 0;
        item.right = 0;
        continue;
      }
      if (layer) {
        item.top = layer.meta.position.absolute.y;
        item.left = layer.meta.position.absolute.x;
        item.bottom = layer.meta.size.height + item.top;
        item.right = layer.meta.size.width + item.left;
        layer.bounds = {
          top: item.top,
          left: item.left,
          bottom: item.bottom,
          right: item.right
        };
      } else {
        item.top = 0;
        item.left = 0;
        item.bottom = 0;
        item.right = 0;
      }
    }
    list.sort(_indexPositionSort);
    isPositionRelative = true;
    bottomBorder = 0;
    for (i = k = 0, ref1 = len; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      item = list[i];
      if (item.enabled) {
        if (bottomBorder <= item.bottom) {
          bottomBorder = item.bottom;
        } else {
          isPositionRelative = false;
          break;
        }
      }
    }
    results = [];
    for (i = l = 0, ref2 = len; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
      item = list[i];
      item.positionRelative = isPositionRelative;
      next = list[i + 1];
      next_id = next ? next.id : null;
      item.next_id = next_id;
      item.prev_id = prev_id;
      layer = layers[item.id];
      if (layer) {
        layer.next_id = next_id;
        layer.prev_id = prev_id;
      }
      if (item.enabled) {
        prev_id = item.id;
      }
      results.push(_setupIndexData(item, layers));
    }
    return results;
  };

  _indexPositionSort = function(a, b) {
    if (a.top === b.top) {
      if (a.left === b.left) {
        return 0;
      } else if (a.left < b.left) {
        return -1;
      }
      return 1;
    } else if (a.top < b.top) {
      return -1;
    }
    return 1;
  };

  _setupDocumentData = function(data, layouts, options) {
    var bottom, height, id, item, layerName, layers, left, maxX, maxY, minX, minY, offsetX, offsetY, pos, ref_id, referers, right, root, size, top, width;
    minX = 999999;
    minY = 0;
    maxX = 0;
    maxY = 0;
    layers = layouts.layers;
    referers = [];
    for (id in layers) {
      item = layers[id];
      layerName = options[id].layer_name;
      if (layerName.match(/^@\d+$/)) {
        ref_id = layerName.match(/^@(\d+)$/)[1];
        if (referers.indexOf(ref_id) < 0) {
          referers.push(ref_id);
        }
      }
      pos = item.meta.position.absolute;
      size = item.meta.size;
      left = pos.x;
      top = pos.y;
      right = left + size.width;
      bottom = top + size.height;
      if (minX > left) {
        minX = left;
      }
      if (maxX < right) {
        maxX = right;
      }
      if (maxY < bottom) {
        maxY = bottom;
      }
    }
    root = options.root;
    width = maxX - minX;
    height = maxY;
    offsetX = minX;
    offsetY = minY;
    data.document = {
      title: root.doc_title,
      filename: root.name.split('.').shift(),
      psd: root.name,
      horizontal: root.horizontal,
      vertical: root.vertical,
      device: root.doc_type,
      width: width,
      height: height,
      offsetX: -offsetX,
      offsetY: -offsetY,
      bgcolor: root.bgcolor,
      margin: root.margin,
      referers: referers
    };
  };

  _setupLayoutNodesData = function(data, layouts, options) {
    var id, index, item, layers, nodes;
    nodes = {};
    layers = layouts.layers;
    index = layouts.index;
    for (id in layers) {
      item = layers[id];
      item.option = options[id];
    }
    data.index = index;
    return data.layers = layers;
  };

  return LayoutJSONParser;

})();

module.exports = jsx;

jsx = jsx || {};

path = require('path');

jsx.StylusTemplate = (function() {
  var INDENT_STR, _PSE_CSS;

  INDENT_STR = '  ';

  _PSE_CSS = '';

  function StylusTemplate() {}

  StylusTemplate.prototype.basicStyle = function(params) {
    var indent, style;
    indent = INDENT_STR;
    style = 'body' + '\n';
    style += indent + 'position: relative' + '\n';
    style += indent + 'margin: 0' + '\n';
    style += indent + 'padding: 0' + '\n';
    style += indent + 'min-height: 100%' + '\n';
    style += indent + 'background: ' + (params.bgcolor || '#FFF') + '\n';
    style += '\n';
    style += '#container' + '\n';
    style += indent + 'position: relative' + '\n';
    style += indent + 'margin: ' + (params.margin || 0) + '\n';
    style += indent + 'padding: 0' + '\n';
    style += indent + 'width: 100%' + '\n';
    style += '\n';
    style += '#main' + '\n';
    style += indent + 'position: relative' + '\n';
    style += indent + 'margin: 0 auto' + '\n';
    style += indent + 'padding: 0' + '\n';
    style += indent + 'width: ' + 100 + '%' + '\n';
    style += indent + 'max-width: ' + params.width + 'px' + '\n';
    style += '\n';
    style += 'p' + '\n';
    style += indent + 'position: relative' + '\n';
    style += indent + 'margin: 0 0 32px' + '\n';
    style += indent + 'padding: 0' + '\n';
    style += '\n';
    style += 'span, a' + '\n';
    style += indent + 'display: inline-block' + '\n';
    style += indent + 'margin: 0' + '\n';
    style += indent + 'padding: 0' + '\n';
    style += '\n';
    style += 'img' + '\n';
    style += indent + 'display: block' + '\n';
    style += indent + 'margin: 0' + '\n';
    style += indent + 'padding: 0' + '\n';
    style += '\n';
    style += this.pse();
    return style;
  };

  StylusTemplate.prototype.pse = function() {
    var indent, style;
    indent = INDENT_STR;
    style = '';
    style += '.pse' + '\n';
    style += indent + 'position: absolute' + '\n';
    style += indent + 'display: block' + '\n';
    style += indent + 'box-sizing: border-box' + '\n';
    style += indent + 'top: 0' + '\n';
    style += indent + 'left: 0' + '\n';
    style += indent + 'margin: 0' + '\n';
    style += indent + 'padding: 0' + '\n';
    style += '\n';
    return style;
  };

  StylusTemplate.prototype.componentBase = function() {
    var indent, style;
    indent = INDENT_STR;
    style = '';
    style += this.pse();
    return style;
  };

  StylusTemplate.prototype.componentBaseCSS = function(callback) {
    if (_PSE_CSS) {
      return callback(_PSE_CSS);
    } else {
      return stylus(this.componentBase()).set('compress', false).use(nib()).render(function(err, css) {
        if (err) {
          return console.log('stylus #render() >>', err);
        } else {
          _PSE_CSS = css;
          return callback(_PSE_CSS);
        }
      });
    }
  };

  StylusTemplate.prototype.textElement = function(meta, indent) {
    var css, ref, ref1, size;
    size = Number(meta.text.size.replace(/\spx/, ''));
    css = '';
    css += indent + 'font-family: "' + meta.text.font + '"' + '\n';
    css += indent + 'font-size:' + meta.text.size.replace(/\s+/g, '') + '' + '\n';
    css += indent + 'color: #' + meta.text.color + '' + '\n';
    css += indent + 'text-align: ' + meta.text.align + '' + '\n';
    if (typeof meta.text.line_height === 'number') {
      css += indent + 'line-height: ' + meta.text.line_height + '' + '\n';
    } else if (typeof meta.text.line_height === 'string') {
      css += indent + 'line-height: ' + ((ref = meta.text.line_height) != null ? ref.replace(/\s+/g, '') : void 0) + '' + '\n';
    }
    css += indent + 'letter-spacing: ' + (((ref1 = meta.text) != null ? ref1.letter_spacing : void 0) / 6000 * size) + 'px' + '\n';
    return css;
  };

  StylusTemplate.prototype.position = function(data, indent, parent, isRelative, isRoot) {
    var css, isFirstNode, isInlineBlock, isLastNode, posLeft, translateX, translateY;
    if (isRelative == null) {
      isRelative = false;
    }
    if (isRoot == null) {
      isRoot = false;
    }
    css = '';
    translateX = 0;
    translateY = 0;
    isFirstNode = data.prev_id === null;
    isLastNode = data.next_id === null;
    isInlineBlock = false;
    if (isRelative) {
      css += indent + 'position: relative' + '\n';
    }
    if (isRoot) {
      return css;
    }
    if (data.option.horizontal === 'center') {
      if (parent) {
        posLeft = data.left - (parent.bounds.right - parent.bounds.left) / 2;
        css += indent + 'left: 50%' + '\n';
        css += indent + 'margin-left: ' + posLeft + 'px' + '\n';
      } else if (isRelative && !isInlineBlock) {
        css += indent + 'margin-left: auto' + '\n';
        css += indent + 'margin-right: auto' + '\n';
      } else {
        css += indent + 'left: 50%' + '\n';
        translateX = '-50%';
      }
    } else if (data.option.horizontal === 'right' && parent) {
      if (isRelative && !isInlineBlock) {
        css += indent + 'margin-left: auto' + '\n';
        css += indent + 'margin-right: ' + (parent.meta.size.width - data.meta.size.width - data.left) + 'px' + '\n';
      } else {
        css += indent + 'right: ' + (parent.meta.size.width - data.meta.size.width - data.left) + 'px' + '\n';
      }
    } else {
      if (data.left !== 0) {
        css += indent + 'left: ' + data.left + 'px' + '\n';
      }
    }
    if (data.option.vertical === 'middle') {
      css += indent + 'margin-top: 50%' + '\n';
      translateY = '-50%';
    } else if (data.option.vertical === 'bottom' && parent) {
      css += indent + 'bottom: ' + (parent.meta.size.height - data.meta.size.height - data.top) + 'px' + '\n';
    } else {
      if (data.top !== 0) {
        css += indent + 'margin-top: ' + data.top + 'px' + '\n';
        if (isFirstNode && data.meta.type === 'image') {
          css += indent + 'display: inline-block' + '\n';
        }
      }
    }
    if (translateX || translateY) {
      css += indent + 'transform: translate(' + translateX + ', ' + translateY + ')' + '\n';
    }
    return css;
  };

  StylusTemplate.prototype.size = function(data, indent) {
    var css, size;
    size = data.meta.size;
    css = '';
    if (data.option.flex === 'w100') {
      css += indent + 'width: ' + '100%' + '\n';
      css += indent + 'max-width: ' + size.width + 'px' + '\n';
    } else {
      css += indent + 'width: ' + size.width + 'px' + '\n';
    }
    css += indent + 'height: ' + size.height + 'px' + '\n';
    return css;
  };

  StylusTemplate.prototype.background = function(data, indent, assetsPath) {
    var bg_url, bg_x, bg_y, css;
    bg_url = path.join(assetsPath, data.background.image);
    bg_x = data.background.pos_x;
    bg_y = data.background.pos_y;
    if (bg_y === 'middle') {
      bg_y = 'center';
    }
    css = '';
    css += indent + 'background: url("../' + bg_url + '") no-repeat' + '\n';
    css += indent + 'background-position: ' + bg_x + ' ' + bg_y + '' + '\n';
    css += indent + 'background-size: cover' + '\n';
    css += indent + 'overflow: hidden' + '\n';
    return css;
  };

  return StylusTemplate;

})();

module.exports = jsx;
